本文字符串下标从 $0$ 开始，$n=|S|$。

## 自动机

**自动机（automaton）** 是一种对信号序列进行判定的数学模型，可以模拟人类的思考方式，对给定的一串信号给出真或假的判定。

**确定有限状态自动机（DFA）** 是自动机的一种，在 OI 中较常用，我们给出它的形式化定义：

- **字符集（$\Sigma$）**，为信号序列所含信号组成的集合。
- **状态集合（$Q$）**，为所有状态构成的集合。DFA 有许多不同含义的状态，可以视作有向图中点。$Q$ 可以视作点集。
- **起始状态（$s$）**，$s\in Q$，为一个特殊的状态，是所有转移的起点。
- **接受状态集合（$F$）**，$F\subseteq Q$，为一些特殊的状态，是判定的依据。
- **转移函数（$\delta$）**，$\delta(u,c)$ 表示 DFA 在读取到字符 $c$，且当前在状态 $u$ 的情况下，DFA 的状态转移到 $\delta(u,c)$。转移函数可以视作无向图的边。如果 $u$ 没有 $c$ 的转移，则约定 $\delta(u,v)=\mathrm{null}$。$\mathrm{null}$ 是一个特殊的状态，其不能转移到任何其他状态，代表了无法接受。

设 DFA $A$ 判定信号序列 $S$，我们有 $A$ 工作流程：

- 设当前状态 $u$，$u$ 初始时为 $s$；
- 依次读取 $S$ 中的每一个字符，设当前读取到字符 $c$，
  - 执行 $u\gets\delta(u,c)$，即通过转移函数，转移到新状态；
- 重复读取 $S$ 并执行上述操作。
- 读取完毕后，如果 $u\in F$，则 $A$ 接受了 $S$，返回 $\mathrm{true}$，记作 $A(S)=\mathrm{true}$。反之不接受，返回 $\mathrm{false}$，记作 $A(S)=\mathrm{false}$。

我们还可以定义扩展转移函数（递归定义）

$$
\Delta(u,S)=
\begin{cases}
	u & n=0\iff S=\varnothing\\
	\Delta(\delta(u,S_0),S[1,n-1]) & \text{otherwise}
\end{cases}
$$

即 $A$ 连续读入 $S$ 内字符后到达的状态。于是我们有 $A(S)=[\Delta(s,S)\in F]$。

定义相对抽象，接下来看应用实例。

## Trie

Trie 的本质就是自动机。在 Trie 中，信号序列就是需要查询的串（称为文本串），判定即判定串是否在字典中。字符集视题目而定。状态集合中的状态 代表输入的文本串 是在字典中的字符串（称为模式串）的某个前缀，起始状态是空字符串，接受状态集合中的状态 代表的字符串 为所有模式串。转移函数就是 在当前状态所代表的串后 添加字符得到的串 所对应的状态。

举例而言，如果有模式串 $\texttt{apple},\texttt{butter},\texttt{appear}$，那么 Trie 就如下图。

![]()

事实上，Trie 可以检测文本串是否等于任意模式串。我们还可以通过 DFA 检测文本串的后缀是否等于模式串。那就是——KMP。

## KMP 自动机

### 匹配

我们希望实现在文本串中查找模式串的功能，而这实现起来有点困难。事实上，我们可以降低对 DFA 的要求，只求输入的串的（任意）后缀是否是模式串。我们一次将文本串的前缀输入 DFA，如果判定为真，就说明在该处匹配了。

例如文本串 $\texttt{apple}$，模式串 $\texttt{pl}$。取出文本串的前缀 $\texttt{appl}$ 扔给 DFA，DFA 返回 $\texttt{appl}$ 的后缀 $\texttt{pl}$ 刚好是模式串，于是匹配。

显然我们可以不需要真的每次都重新判定前缀，例如 $\texttt{app}$ 判定后终止状态为 $u=\Delta(s,\texttt{app})$，判定 $\texttt{appl}$ 只需要转移到 $\Delta(s,\texttt{appl})=\delta(u,\texttt{l})$ 即可。换句话说，我们依次加入文本串中的每个字符后，判定是否接受（匹配）。

于是匹配和 DFA 就是两回事了。匹配需要若干次运行 DFA，得到结果。在 KMP 自动机中，信号序列不再是文本串，而是文本串的前缀，叫输入串。

### 冲突

但是可以发现，对于文本串的每个前缀，其可能有多个后缀是模式串。因为一个字符串有多个后缀，而较短的后缀一定是较长的后缀的后缀。所以符合某个状态 $u$ 的输入串，也一定能符合 $u$ 所代表的字符串的后缀的状态。

例如文本串 $\texttt{apple}$，模式串 $\texttt{ppl},\texttt{pl}$。文本串前缀 $\texttt{appl}$ 同时匹配了两个模式串。符合 $\texttt{ppl}$ 的输入串也符合 $\texttt{pl}$。

### 状态设计与 fail 指针

为了既使状态互相独立，有匹配所有模式串，在 KMP 自动机中，每个状态代表“该状态代表的串是 最长的 满足等于某模式串前缀的 输入串的后缀”。这样只有最长的输入串的后缀匹配，那么如何匹配其他的后缀？我们考虑让表示串 $t$ 的状态 $u$ 继承所有代表 $t$ 的后缀的状态，即继承其他输入串的后缀。如何完成继承？我们构建 fail 指针（失配链接），对于 $u$ 找到代表的串 $r$ 最长的状态 $v$，使得 $v$ 满足 $r$ 是 $t$ 的真后缀。假设我们已经递归地使 $v$ 继承了代表 $r$ 的后缀的状态，那么再使 $u$ 继承 $v$（通过连 fail 指针实现）就（间接和直接）继承了代表 $t$ 的后缀的状态。

注意 fail 指针只是代表一种继承关系，并不是转移。我们保存 fail 指针，是为了复制 fail 指针指向的状态的信息以及将来使用。

### 构建

- 初始时，初始状态 $s$ 是接受状态；
- 遍历模式串中的每个字符 $c$，
  - 新建一个状态 $u$，将当前接受状态 $f$ 添加字符 $c$ 的转移到 $u$；
  - $u$ 的 fail 指针为 $f$ 的 fail 指针的字符 $c$ 转移到的状态；
  - 将 $u$ 的 fail 指针指向的状态的转移复制给 $u$；
  - $f\gets u$，即将 $f$ 设为非接受状态，$u$ 设为接受状态。
- 注意每个状态的所有转移默认转移到初始状态 $s$。最后只有代表模式串的状态是接受状态。

### 查询

对于要查询的文本串的每个前缀，交给 DFA 判定。如果返回真（停在接受状态），则匹配。

## AC 自动机

AC 自动机和 KMP 自动机的关系，等同于字典树和只含一个串的字典树的关系。AC 自动机中可能有多个模式串，但大体上和 KMP 自动机相同。

### 构建

分两步走：先建立朴素的转移（建 Trie），然后 bfs 求 fail 指针。bfs 保证先访问表示的串长度更短的状态。

### 查询

AC 自动机与 KMP 自动机不同，它有多个接受状态。又由于有 fail 指针和继承，使得关系错综复杂。如果我们要求每个模式串的出现次数，该怎么做？考虑朴素查询方法：因为满足某个状态的输入串一定满足 表示该状态所表示的串的后缀的状态（即 fail 指针指向的状态，以及 fail 的 fail 等等），也就是该状态继承的状态。所以转移后到达结束状态时，不停地跳 fail，统计答案。但这样可能使复杂度爆炸，因为我们要判定每个前缀。

#### 拓扑统计

对于每次判定，到达结束状态时对该状态打标记。若干次判定结束后统一进行统计。对 fail 指针组成的 DAG（其实是根向树）进行拓扑排序，每个状态的贡献为自己的贡献加上所有 fail 指针指向自己的状态的贡献。可以在拓扑中实现。另一种是建树进行 dfs，二者等价。

### 代码

- 暴力跳 fail：<>；
- 拓扑统计：<>。

## 参考

- [Bilibili 【manim | 算法】OI自动机大炒饭（字典树，KMP自动机，AC自动机，后缀自动机，广义后缀自动机）](https://www.bilibili.com/video/BV1uV4y1W7cB/)